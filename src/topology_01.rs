use std::collections::HashMap;
use petgraph::graph::{UnGraph};

/// Generate topology 01 undirected graph
pub fn generate_graph() -> UnGraph<i32, ()> {
    UnGraph::<i32, ()>::from_edges(&[
        (0, 1), (0, 5),
        (1, 2), (1, 6),
        (2, 3), (2, 7), (2, 6),
        (3, 7), (3, 4), (3, 8),
        (4, 9), (4, 8),
        (5, 6), (5, 10),
        (6, 7), (6, 11), (6, 10),
        (7, 8), (7, 12), (7, 11),
        (8, 9), (8, 13), (8, 12),
        (9, 13),
        (10, 11), (10, 15),
        (11, 12), (11, 15),
        (12, 13), (12, 18), (12, 17), (12, 15),
        (13, 14), (13, 18),
        (14, 18),
        (15, 17), (15, 16),
        (16, 17),
        (17, 18),
        (18, 14)
    ])
}

/// Generate demands for topology 01
/// Demand is generated by the formula:
/// NODE_NUMBER + UNIFORM(0, 1) * 15
///
/// the UNIFORM(0, 1) part is only run once, at the start
/// of the simulation.
pub fn generate_demands() -> HashMap<usize, i32> {
    let mut hash = HashMap::new();
    for i in 0..=18 {
        let demand = i as f64 + 15.0 * crate::random::uniform_0_to_1();
        hash.insert(i, demand as i32);
    }


    hash
}

pub fn renew_demands(hash: &mut HashMap<usize, i32>) {
    for i in 0..=18 {
        let demand = i as f64 + 15.0 * crate::random::uniform_0_to_1();
        hash.insert(i, hash[&i] + demand as i32);
    }
}


/// Generate the capacity number: The number of
/// bikes at each station.
///
/// Note that while we define an initial number, each rider will
/// remove a bike when he starts travelling and return it after his trip is done.
pub fn generate_station_loads() -> HashMap<usize, i32> {
    let mut hash = HashMap::new();
    for i in 0..=18 {
        let load = i as f64 + 12.0 * crate::random::uniform_0_to_1();
        hash.insert(i, load as i32);
    }


    hash
}